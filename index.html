<html>
  <head>
    <meta charset="utf-8">
    <title>üò∏ vs. üê∂ stats</title>
    <style>
      h1 {
        font-size: 50px;
        font-family: Helvetica, sans-serif;
      }
      button#cats-only {
        background-color: steelblue;
      }
      button#dogs-only {
        background-color: salmon;
      }
      button#both {
        background-color: grey;
      }
    </style>
    <script src="https://d3js.org/d3.v4.min.js"></script>
  </head>
  <body>
    <p>
      <label for="nRadius" 
             style="display: inline-block; width: 240px; text-align: right">
             radius = <span id="nRadius-value">‚Ä¶</span>
      </label>
      <input type="range" min="1" max="150" id="nRadius">
    </p>
    <input id="test" type="range"/>
    <script>

      // Set up size
      var mapWidth = 750;
      var mapHeight = 750;

      // Set up projection that the map is using
      var projection = d3.geoMercator()
        .center([-122.433701, 37.767683]) // San Francisco, roughly
        .scale(225000)
        .translate([mapWidth / 2, mapHeight / 2]);

      // This is the mapping between <longitude, latitude> position to <x, y> pixel position on the map
      // projection is a function and it has an inverse:
      // projection([lon, lat]) returns [x, y]
      // projection.invert([x, y]) returns [lon, lat]

      // Add an SVG element to the DOM
      var svg = d3.select('body').append('svg')
        .attr('width', mapWidth)
        .attr('height', mapHeight);

      // Add SVG map at correct size, assuming map is saved in a subdirectory called `data`
      svg.append('image')
        .attr('width', mapWidth)
        .attr('height', mapHeight)
        .attr('xlink:href', 'sf-map.svg');

        let plot = svg.append('g').attr('transform', `translate(0,0)`);

      /*var projectedLocation = projection([-122.433701, 37.767683]);// [treeLon, treeLat]);
      console.log(projectedLocation);
      var circle = svg.append('circle')
        .attr('cx', projectedLocation[0])
        .attr('cy', projectedLocation[1])
        .attr('r', 5);*/

        d3.csv('trees.csv', parseInputRow, loadData);


        // Convert weight and height from strings to numbers
        function parseInputRow (d) {
          return {
            TreeID: +d.TreeID,
            qSpecies: d.qSpecies,
            qAddress: d.qAddress,
            qSiteInfo: d.qSiteInfo,
            DBH: +d.DBH,
            PlotSize: d.PlotSize,
            Latitude: +d.Latitude,
            Longitude: +d.Longitude
          };
        }

        function loadData (error, data) {
          if (error) throw error; // Runs if there's a problem fetching the csv.

          // data looks like
          // [
          //   {TreeID: "cat", qSpecies: 10, qAddress: 3},
          //   {animal: "cat", weight: 3, height: 3},
          //   ...
          // ]

          // Draw the initial scatter plot
          drawScatterPlot(data);

          // Set up event handlers for our buttons.
          // You could also do this with plain JavaScript!
          // e.g. document.querySelectorAll('button') ... addEventListener ...
          // D3 just provides convenient methods for operating on DOM nodes
          // through its selections
          let ranges = d3.selectAll('input');
          ranges.on('change', function() {
            // When you write a function for a D3 selection with multiple nodes
            // `this` refers to the current DOM node
            console.log("change");
            /*let chosenAnimal = this.dataset.filter; // value of `data-filter` attr
            let filteredData;
            if (chosenAnimal === 'both') {
              filteredData = animalData;
            } else {
              filteredData = animalData.filter( d => d.animal === chosenAnimal );
            }*/
            drawScatterPlot(data);
          });
        }

        function drawScatterPlot(data) {
          // Create a selection of circles in our plot (empty on the first go)
          let circles = plot.selectAll('circle');
          // Bind our animal data to the circles, using the "id" field as our key
          let updatedCircles = circles.data(data, d => d.TreeID);

          // Could also set the key to "name"!
          // The key for each datapoint can be anything, ideally a unique feature of each datum.
          // If we already have circles that have data joined, D3 will compare the keys
          // of each of those with the keys of the joined data to see:
          // * Does our dataset have datums that aren't already represented by nodes? (we can `enter` these)
          // * Are there nodes which no longer have corresponding datums in the dataset? (we can `exit` these)
          // * Are there nodes whose keys match the keys of the dataset? (these are the `update` selection)
          // By default, D3 uses the index in the data array, in our example that won't work.

          // We'll use "enter" to make circles for new datapoints
          // From https://github.com/d3/d3-selection#selection_enter :
          // "The enter selection is typically used to create 'missing' elements corresponding to new data."
          // "[The selection comprises] placeholder nodes for each datum that had no corresponding DOM element in the selection."
          // "Conceptually, the enter selection‚Äôs placeholders are pointers to the parent element"
          let enterSelection = updatedCircles.enter();
          //let projectedLocation = projection([d.Longitude, d.Latitude]); // [treeLon, treeLat]);


          var circle = enterSelection.append('circle')
            .attr('cx', function (d) { return projection([d.Longitude, d.Latitude])[0]; })
            .attr('cy', function (d) { return projection([d.Longitude, d.Latitude])[1]; })
            .attr('r', 1);
            


          // Now we'll select all the circles that no longer
          // have any corresponding data after the data join
          let unselectedCircles = updatedCircles.exit();
          // And we'll remove those nodes form the DOM - poof!
          updatedCircles.exit().remove();
        }

        // draw the circle
        svg.append("circle")
          .attr("cx", 300)
          .attr("cy", 150) 
          .style("fill", "none")   
          .style("stroke", "blue") 
          .attr("r", 120)
          .attr("id", function(d){ return "POI"; })
          .append("g")
          

        // when the input range changes update the circle 
        d3.select("#nRadius").on("input", function() {
          update(+this.value);
        });

        // Initial starting radius of the circle 
        update(120);

        // update the elements
        function update(nRadius) {

          // adjust the text on the range slider
          d3.select("#nRadius-value").text(nRadius);
          d3.select("#nRadius").property("value", nRadius);

          // update the rircle radius
          svg.select("#POI") 
            .attr("r", nRadius);
        }



    </script>
  </body>
</html>
